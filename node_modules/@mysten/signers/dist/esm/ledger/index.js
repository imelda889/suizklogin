var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _derivationPath, _publicKey, _ledgerClient, _suiClient, _LedgerSigner_instances, getClearSigningOptions_fn;
import { messageWithIntent, Signer, toSerializedSignature } from "@mysten/sui/cryptography";
import { Ed25519PublicKey } from "@mysten/sui/keypairs/ed25519";
import { Transaction } from "@mysten/sui/transactions";
import { toBase64 } from "@mysten/sui/utils";
import { SuiMoveObject } from "./bcs.js";
import { bcs } from "@mysten/sui/bcs";
const _LedgerSigner = class _LedgerSigner extends Signer {
  /**
   * Creates an instance of LedgerSigner. It's expected to call the static `fromDerivationPath` method to create an instance.
   * @example
   * ```
   * const signer = await LedgerSigner.fromDerivationPath(derivationPath, options);
   * ```
   */
  constructor({ publicKey, derivationPath, ledgerClient, suiClient }) {
    super();
    __privateAdd(this, _LedgerSigner_instances);
    __privateAdd(this, _derivationPath);
    __privateAdd(this, _publicKey);
    __privateAdd(this, _ledgerClient);
    __privateAdd(this, _suiClient);
    __privateSet(this, _publicKey, publicKey);
    __privateSet(this, _derivationPath, derivationPath);
    __privateSet(this, _ledgerClient, ledgerClient);
    __privateSet(this, _suiClient, suiClient);
  }
  /**
   * Retrieves the key scheme used by this signer.
   */
  getKeyScheme() {
    return "ED25519";
  }
  /**
   * Retrieves the public key associated with this signer.
   * @returns The Ed25519PublicKey instance.
   */
  getPublicKey() {
    return __privateGet(this, _publicKey);
  }
  /**
   * Signs the provided transaction bytes.
   * @returns The signed transaction bytes and signature.
   */
  async signTransaction(bytes) {
    const transactionOptions = await __privateMethod(this, _LedgerSigner_instances, getClearSigningOptions_fn).call(this, bytes).catch(() => ({
      // Fail gracefully so network errors or serialization issues don't break transaction signing:
      bcsObjects: []
    }));
    const intentMessage = messageWithIntent("TransactionData", bytes);
    const { signature } = await __privateGet(this, _ledgerClient).signTransaction(
      __privateGet(this, _derivationPath),
      intentMessage,
      transactionOptions
    );
    return {
      bytes: toBase64(bytes),
      signature: toSerializedSignature({
        signature,
        signatureScheme: this.getKeyScheme(),
        publicKey: __privateGet(this, _publicKey)
      })
    };
  }
  /**
   * Signs the provided personal message.
   * @returns The signed message bytes and signature.
   */
  async signPersonalMessage(bytes) {
    const intentMessage = messageWithIntent(
      "PersonalMessage",
      bcs.byteVector().serialize(bytes).toBytes()
    );
    const { signature } = await __privateGet(this, _ledgerClient).signTransaction(
      __privateGet(this, _derivationPath),
      intentMessage
    );
    return {
      bytes: toBase64(bytes),
      signature: toSerializedSignature({
        signature,
        signatureScheme: this.getKeyScheme(),
        publicKey: __privateGet(this, _publicKey)
      })
    };
  }
  /**
   * Prepares the signer by fetching and setting the public key from a Ledger device.
   * It is recommended to initialize an `LedgerSigner` instance using this function.
   * @returns A promise that resolves once a `LedgerSigner` instance is prepared (public key is set).
   */
  static async fromDerivationPath(derivationPath, ledgerClient, suiClient) {
    const { publicKey } = await ledgerClient.getPublicKey(derivationPath);
    if (!publicKey) {
      throw new Error("Failed to get public key from Ledger.");
    }
    return new _LedgerSigner({
      derivationPath,
      publicKey: new Ed25519PublicKey(publicKey),
      ledgerClient,
      suiClient
    });
  }
  /**
   * Generic signing is not supported by Ledger.
   * @throws Always throws an error indicating generic signing is unsupported.
   */
  sign() {
    throw new Error("Ledger Signer does not support generic signing.");
  }
  /**
   * Generic signing is not supported by Ledger.
   * @throws Always throws an error indicating generic signing is unsupported.
   */
  signWithIntent() {
    throw new Error("Ledger Signer does not support generic signing.");
  }
};
_derivationPath = new WeakMap();
_publicKey = new WeakMap();
_ledgerClient = new WeakMap();
_suiClient = new WeakMap();
_LedgerSigner_instances = new WeakSet();
getClearSigningOptions_fn = async function(transactionBytes) {
  const transaction = Transaction.from(transactionBytes);
  const data = transaction.getData();
  const gasObjectIds = data.gasData.payment?.map((object) => object.objectId) ?? [];
  const inputObjectIds = data.inputs.map((input) => {
    return input.$kind === "Object" && input.Object.$kind === "ImmOrOwnedObject" ? input.Object.ImmOrOwnedObject.objectId : null;
  }).filter((objectId) => !!objectId);
  const objects = await __privateGet(this, _suiClient).multiGetObjects({
    ids: [...gasObjectIds, ...inputObjectIds],
    options: {
      showBcs: true,
      showPreviousTransaction: true,
      showStorageRebate: true,
      showOwner: true
    }
  });
  const bcsObjects = objects.map((object) => {
    if (object.error || !object.data || object.data.bcs?.dataType !== "moveObject") {
      return null;
    }
    return SuiMoveObject.serialize({
      data: {
        MoveObject: {
          type: object.data.bcs.type,
          hasPublicTransfer: object.data.bcs.hasPublicTransfer,
          version: object.data.bcs.version,
          contents: object.data.bcs.bcsBytes
        }
      },
      owner: object.data.owner,
      previousTransaction: object.data.previousTransaction,
      storageRebate: object.data.storageRebate
    }).toBytes();
  }).filter((bcsBytes) => !!bcsBytes);
  return { bcsObjects };
};
let LedgerSigner = _LedgerSigner;
export {
  LedgerSigner
};
//# sourceMappingURL=index.js.map
